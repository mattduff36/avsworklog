/**
 * report.ts
 *
 * Merges Playwright JSON and Vitest JSON test results into a single
 * markdown summary at testsuite/reports/latest.md
 *
 * Usage: npx tsx testsuite/runner/report.ts
 */
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { resolve } from 'path';

const REPORTS_DIR = resolve(process.cwd(), 'testsuite', 'reports');
const PW_RESULTS = resolve(REPORTS_DIR, 'results.json');
const VITEST_RESULTS = resolve(REPORTS_DIR, 'vitest-results.json');
const OUTPUT = resolve(REPORTS_DIR, 'latest.md');

interface FailureEntry {
  name: string;
  suite: string;
  source: 'playwright' | 'vitest';
  error: string;
  file: string;
}

function parsePlaywrightResults(): FailureEntry[] {
  if (!existsSync(PW_RESULTS)) return [];

  try {
    const raw = JSON.parse(readFileSync(PW_RESULTS, 'utf-8'));
    const failures: FailureEntry[] = [];

    for (const suite of raw.suites || []) {
      walkPlaywrightSuite(suite, failures);
    }

    return failures;
  } catch {
    console.warn('Could not parse Playwright results');
    return [];
  }
}

function walkPlaywrightSuite(suite: any, failures: FailureEntry[]): void {
  for (const spec of suite.specs || []) {
    for (const test of spec.tests || []) {
      for (const result of test.results || []) {
        if (result.status === 'failed' || result.status === 'timedOut') {
          failures.push({
            name: spec.title,
            suite: suite.title || 'Unknown Suite',
            source: 'playwright',
            error: result.error?.message || result.error?.snippet || 'Unknown error',
            file: spec.file || suite.file || 'unknown',
          });
        }
      }
    }
  }

  for (const child of suite.suites || []) {
    walkPlaywrightSuite(child, failures);
  }
}

function parseVitestResults(): FailureEntry[] {
  if (!existsSync(VITEST_RESULTS)) return [];

  try {
    const raw = JSON.parse(readFileSync(VITEST_RESULTS, 'utf-8'));
    const failures: FailureEntry[] = [];

    for (const file of raw.testResults || []) {
      for (const test of file.assertionResults || []) {
        if (test.status === 'failed') {
          failures.push({
            name: test.title || test.fullName,
            suite: test.ancestorTitles?.join(' > ') || 'Unknown Suite',
            source: 'vitest',
            error: test.failureMessages?.join('\n') || 'Unknown error',
            file: file.name || 'unknown',
          });
        }
      }
    }

    return failures;
  } catch {
    console.warn('Could not parse Vitest results');
    return [];
  }
}

function generateReport(): void {
  const pwFailures = parsePlaywrightResults();
  const vitestFailures = parseVitestResults();
  const allFailures = [...pwFailures, ...vitestFailures];

  const lines: string[] = [
    '# Test Suite Report',
    '',
    `**Generated**: ${new Date().toISOString()}`,
    '',
    '## Summary',
    '',
  ];

  // Count stats
  let pwTotal = 0;
  let pwPassed = 0;
  let vitestTotal = 0;
  let vitestPassed = 0;

  if (existsSync(PW_RESULTS)) {
    try {
      const raw = JSON.parse(readFileSync(PW_RESULTS, 'utf-8'));
      const stats = raw.stats || {};
      pwTotal = (stats.expected || 0) + (stats.unexpected || 0) + (stats.skipped || 0);
      pwPassed = stats.expected || 0;
    } catch {}
  }

  if (existsSync(VITEST_RESULTS)) {
    try {
      const raw = JSON.parse(readFileSync(VITEST_RESULTS, 'utf-8'));
      vitestTotal = raw.numTotalTests || 0;
      vitestPassed = raw.numPassedTests || 0;
    } catch {}
  }

  const totalTests = pwTotal + vitestTotal;
  const totalPassed = pwPassed + vitestPassed;
  const totalFailed = allFailures.length;

  lines.push(`- **Total tests**: ${totalTests}`);
  lines.push(`- **Passed**: ${totalPassed}`);
  lines.push(`- **Failed**: ${totalFailed}`);
  lines.push(`- **Playwright tests**: ${pwTotal} (${pwFailures.length} failures)`);
  lines.push(`- **Vitest tests**: ${vitestTotal} (${vitestFailures.length} failures)`);
  lines.push('');

  if (allFailures.length === 0) {
    lines.push('## Result: ALL TESTS PASSED');
    lines.push('');
    lines.push('No failures detected.');
  } else {
    lines.push('## Failures');
    lines.push('');

    for (let i = 0; i < allFailures.length; i++) {
      const f = allFailures[i];
      lines.push(`### ${i + 1}. ${f.name}`);
      lines.push('');
      lines.push(`- **Suite**: ${f.suite}`);
      lines.push(`- **Source**: ${f.source}`);
      lines.push(`- **File**: \`${f.file}\``);
      lines.push(`- **Error**:`);
      lines.push('```');
      lines.push(f.error.slice(0, 500));
      lines.push('```');
      lines.push('');
    }
  }

  lines.push('---');
  lines.push('');
  lines.push('*This report was auto-generated by `testsuite/runner/report.ts`.*');

  if (!existsSync(REPORTS_DIR)) {
    mkdirSync(REPORTS_DIR, { recursive: true });
  }

  writeFileSync(OUTPUT, lines.join('\n'));
  console.log(`Report written to: ${OUTPUT}`);
  console.log(`  Total: ${totalTests}, Passed: ${totalPassed}, Failed: ${totalFailed}`);
}

generateReport();
